rm(list = ls())
data=read.csv("data.csv")
data$日期=as.Date(data$日期)
data_no_date=data[,2:7]

library(quadprog)
library(quantmod)
# rm(list = ls())

# 风险平价模型（Risk Parity Portfolio）
earning_rate=data
for (i in 2:7) {
  for (j in nrow(data):2) {
    earning_rate[j,i]=(data[j,i]-data[j-1,i])/data[j-1,i]
  }
}
earning_rate=earning_rate[,2:7]
earning_rate=earning_rate[-1,]
# summary(earning_rate)
RiskParity = function(Sub) #Sub是N行M列的数据，N个日期，M个资产的收益
{
  m = ncol(Sub)
  Cov = matrix(cov(Sub, use = "na.or.complete"), m, m)
  TotalTRC = function(x)
  {
    x = matrix(c(x, 1-sum(x)))
    TRC = as.vector((Cov %*% x) * x)
    return(sum(outer(TRC, TRC, "-")^2))
  }
  sol = optim(par = rep(1/m,m-1), TotalTRC)
  w = c(sol$par, 1-sum(sol$par))
  return(w)
}
RiskParity(earning_rate)
Configuration_method1=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Configuration_method1[1,]=1/6

for (i in 1:(as.integer(nrow(data)/30)-1)) {
  temp=RiskParity(earning_rate[((i-1)*30+1):((i-1)*30+30),])
  Configuration_method1[i+1,1]=sum(Configuration_method1[i,])*temp[1]
  Configuration_method1[i+1,2]=sum(Configuration_method1[i,])*temp[2]
  Configuration_method1[i+1,3]=sum(Configuration_method1[i,])*temp[3]
  Configuration_method1[i+1,4]=sum(Configuration_method1[i,])*temp[4]
  Configuration_method1[i+1,5]=sum(Configuration_method1[i,])*temp[5]
  Configuration_method1[i+1,6]=sum(Configuration_method1[i,])*temp[6]
}

# 去除负值
for (j in 1:6) {
  for (i in 1:nrow(Configuration_method1)) {
    Configuration_method1[i,j]=Configuration_method1[i,j]-(min(Configuration_method1[i,]))+1e-6
  } 
}
# 回测

result1=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
result1[1,]=1/6

for (i in 2:nrow(result1)) {
  property_sum=sum(result1[i-1,])
  rate_sum=sum(Configuration_method1[i,])
  for (j in 1:6) {
    result1[i,j]=property_sum*
      (Configuration_method1[i,j]/rate_sum)*
      (data_no_date[(i-1)*30+30,j]/data_no_date[(i-1)*30+1,j])
  }
}

for (i in 1:nrow(result1)) {
  result1[i,1]=sum(result1[i,])
}
for (i in 2:nrow(result1)) {
  result1[i,1]=result1[i-1,1]*result1[i,1]
}
result1=data.frame(result1[,1])




# 最小方差模型（Minimum Variance Portfolio）

earning_rate=data
for (i in 2:7) {
  for (j in nrow(data):2) {
    earning_rate[j,i]=(data[j,i]-data[j-1,i])/data[j-1,i]
  }
}
earning_rate=earning_rate[,2:7]
earning_rate=earning_rate[-1,]

data_no_date=data[,2:7]

Configuration_method2=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))

# 先使用Configuration_method2暂存方差列表，并进行标准化
for (j in 1:6) {
  for (i in 1:nrow(Configuration_method2)) {
    Configuration_method2[i,j]=sd(earning_rate[((i-1)*30+1):((i-1)*30+30),j])
    # Configuration_method2[i,j]=Configuration_method2[i,j]*Configuration_method2[i,j]
  }
  Configuration_method2[,j]=scale(Configuration_method2[,j])
}
# for (j in 1:6) {
#   for (i in 1:nrow(Configuration_method2)) {
#     Configuration_method2[i,j]=Configuration_method2[i,j]*Configuration_method2[i,j]
#   }
# }
# 计算协方差，存储在6个dataframe中
Variance_list1=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Variance_list2=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Variance_list3=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Variance_list4=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Variance_list5=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Variance_list6=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))

for (j in 1:6) {
  for (i in 1:nrow(Configuration_method2)) {
    Variance_list1[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
                               earning_rate[((i-1)*30+1):((i-1)*30+30),1],)
  }
  Variance_list1[,j]=scale(Variance_list1[,j])
}
for (j in 1:6) {
  for (i in 1:nrow(Configuration_method2)) {
    Variance_list2[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
                            earning_rate[((i-1)*30+1):((i-1)*30+30),2],)
  }
  Variance_list2[,j]=scale(Variance_list2[,j])
}
for (j in 1:6) {
  for (i in 1:nrow(Configuration_method2)) {
    Variance_list3[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
                            earning_rate[((i-1)*30+1):((i-1)*30+30),3],)
  }
  Variance_list3[,j]=scale(Variance_list3[,j])
}
for (j in 1:6) {
  for (i in 1:nrow(Configuration_method2)) {
    Variance_list4[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
                            earning_rate[((i-1)*30+1):((i-1)*30+30),4],)
  }
  Variance_list4[,j]=scale(Variance_list4[,j])
}
for (j in 1:6) {
  for (i in 1:nrow(Configuration_method2)) {
    Variance_list5[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
                            earning_rate[((i-1)*30+1):((i-1)*30+30),5],)
  }
  Variance_list5[,j]=scale(Variance_list5[,j])
}
for (j in 1:6) {
  for (i in 1:nrow(Configuration_method2)) {
    Variance_list6[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
                            earning_rate[((i-1)*30+1):((i-1)*30+30),6],)
  }
  Variance_list6[,j]=scale(Variance_list6[,j])
}

# 协方差的作用是作为方差的约束条件，即满足最小方差规则,此处做该判断
for (i in 1:6) {
  for (j in 1:6) {
    for (k in 1:nrow(Configuration_method2)) {
      # Configuration_method2[i,j]
      # get(paste("Variance_list",i,sep = ""))[1,2]
      if (Configuration_method2[i,j]<get(paste("Variance_list",i,sep = ""))[k,j]) {
        Configuration_method2[i,j]=get(paste("Variance_list",i,sep = ""))[k,j]
      }
    }
  }
}

# 规范化资产配置比例，去除负值（因为要转化为资产配置比例）
for (j in 1:6) {
  for (i in 1:nrow(Configuration_method2)) {
    Configuration_method2[i,j]=Configuration_method2[i,j]-(min(Configuration_method2[i,]))+1e-6
  } 
  
}

# 回测
# 该过程中，将Configuration_method2理解为下一个投资周期全部资产分配的比例
# result存储每次投资后的结果
result2=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
result2[1,]=1/6

for (i in 2:nrow(result2)) {
  property_sum=sum(result2[i-1,])
  rate_sum=sum(Configuration_method2[i,])
  for (j in 1:6) {
    result2[i,j]=property_sum*
      (Configuration_method2[i,j]/rate_sum)*
      (data_no_date[(i-1)*30+30,j]/data_no_date[(i-1)*30+1,j])
  }
}

for (i in 1:nrow(result2)) {
  result2[i,1]=sum(result2[i,])
}
result2=data.frame(result2[,1])







# Black-Litterman Model


# 计算风险指数，这里理解为每个投资周期亏空日期占比
risk=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
for (i in 1:nrow(risk)) {
  
  for (j in 1:6) {
    count=0
    for (k in 2:30) {
      if (data_no_date[(i-1)*30+k,j]>data_no_date[(i-1)*30+k-1,j]) {
        count=count+1
      }
    }
    risk[i,j]=count/30
  }
}

# 确定风险水平与主观预期影响下收益最大化的配置策略
# 主观预期是该模型的重点，这里认为是上期投资的收益率在影响
# 在实际模型中可能是新闻资讯，关联市场状况等的影响,但此处无法获得这些信息
Configuration_method3=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))

for (i in 1:nrow(Configuration_method3)) {
  for (j in 1:6) {
    Configuration_method3[i,j]=(data_no_date[(i-1)*30+30,j]-data_no_date[(i-1)*30+1,j])/data_no_date[(i-1)*30+1,j]*risk[i,j]
  }
}
for (j in 1:6) {
  for (i in 1:nrow(Configuration_method3)) {
    Configuration_method3[i,j]=Configuration_method3[i,j]-(min(Configuration_method3[i,])+1e-6)
  } 
}

# 回测
result3=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
result3[1,]=1/6
# 同上，将Configuration_method3理解为下一个投资周期全部资产分配的比例
# result3存储每次投资后的结果
for (i in 2:nrow(result3)) {
  
  property_sum=sum(result3[i-1,])
  rate_sum=sum(Configuration_method3[i,])
  for (j in 1:6) {
    result3[i,j]=property_sum*
      (Configuration_method3[i,j]/rate_sum)*
      (data_no_date[(i-1)*30+30,j]/data_no_date[(i-1)*30+1,j])
  }
}

for (i in 1:nrow(result3)) {
  result3[i,1]=sum(result3[i,])
}
result3=data.frame(result3[,1])




# 指标分析与模型选择
result=data.frame(result1,result2,result3)
result[1,]=1
result=result[1:85,]
colnames(result)=c("M1","M2","M3")

library(PerformanceAnalytics)
tsdata=ts(result)

table.AnnualizedReturns(tsdata[,1])
table.AnnualizedReturns(tsdata[,2])
table.AnnualizedReturns(tsdata[,3])


# 最大回撤
library(tseries)
maxdrawdown(tsdata[,1])
maxdrawdown(tsdata[,2])
maxdrawdown(tsdata[,3])


# VaR
method=1
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
  return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,1]
VaR1=as.numeric(quantile(-return,0.95,lw=T))

method=2
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
  return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,method]
VaR2=as.numeric(quantile(-return,0.95,lw=T))

method=3
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
  return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,method]
VaR3=as.numeric(quantile(-return,0.95,lw=T))

# 每月胜率
winning_rate_Monthly=data.frame(matrix(nrow = 1,ncol = 3))
colnames(winning_rate_Monthly)=c("Risk Parity Portfolio",
                                 "Minimum Variance Portfolio",
                                 "Black-Litterman Model")
for (i in 1:3) {
  count=0
  for (j in 2:nrow(result)) {
    if (result[j,i]>result[j-1,i]) {
      count=count+1
    }
  }
  winning_rate_Monthly[1,i]=count/(nrow(result-1))
}

# 变量汇总
variable_summary=data.frame(matrix(nrow = 3,ncol = 6))
colnames(variable_summary)=c("年化收益","波动率","夏普比率","最大回撤","VaR","每月胜率")
rownames(variable_summary)=c("Risk Parity Portfolio",
                             "Minimum Variance Portfolio",
                             "Black-Litterman Model")

variable_summary[1,1]=as.numeric(table.AnnualizedReturns(tsdata[,1])[1,1][1])
variable_summary[2,1]=as.numeric(table.AnnualizedReturns(tsdata[,2])[1,1][1])
variable_summary[3,1]=as.numeric(table.AnnualizedReturns(tsdata[,3])[1,1][1])

variable_summary[1,2]=as.numeric(table.AnnualizedReturns(tsdata[,1])[2,1][1])
variable_summary[2,2]=as.numeric(table.AnnualizedReturns(tsdata[,2])[2,1][1])
variable_summary[3,2]=as.numeric(table.AnnualizedReturns(tsdata[,3])[2,1][1])

variable_summary[1,3]=as.numeric(table.AnnualizedReturns(tsdata[,1])[3,1][1])
variable_summary[2,3]=as.numeric(table.AnnualizedReturns(tsdata[,2])[3,1][1])
variable_summary[3,3]=as.numeric(table.AnnualizedReturns(tsdata[,3])[3,1][1])

variable_summary[1,4]=as.numeric(maxdrawdown(tsdata[,1])[1])
variable_summary[2,4]=as.numeric(maxdrawdown(tsdata[,2])[1])
variable_summary[3,4]=as.numeric(maxdrawdown(tsdata[,3])[1])

variable_summary[1,5]=VaR1
variable_summary[2,5]=VaR2
variable_summary[3,5]=VaR3

variable_summary[1,6]=winning_rate_Monthly[1,1]
variable_summary[2,6]=winning_rate_Monthly[1,2]
variable_summary[3,6]=winning_rate_Monthly[1,3]

head(variable_summary)

