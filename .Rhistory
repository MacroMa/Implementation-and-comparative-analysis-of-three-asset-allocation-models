VaR=quantile(-return,955,lw=T)
VaR=quantile(-return,95%,lw=T)
VaR=quantile(-return,0.95,lw=T)
VaR
quantile(-return,0.95,lw=T)
method=2
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,1]
quantile(-return,0.95,lw=T)
method=2
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
View(return)
return=return[2:84,method]
quantile(-return,0.95,lw=T)
method=3
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,method]
quantile(-return,0.95,lw=T)
'VaR3:'quantile(-return,0.95,lw=T)
'VaR3:';quantile(-return,0.95,lw=T)
'VaR1:';quantile(-return,0.95,lw=T)
colnames(winning_rate_Monthly)=c("Risk Parity Portfolio",
"Minimum Variance Portfolio",
"Black-Litterman Model")
winning_rate_Monthly=data.frame(matrix(nrow = 1,ncol = 3))
colnames(winning_rate_Monthly)=c("Risk Parity Portfolio",
"Minimum Variance Portfolio",
"Black-Litterman Model")
View(winning_rate_Monthly)
View(result)
View(result)
for (i in 1:3) {
count=0
for (j in 2:nrow(resut)) {
if (result[j,i]>result[j-1,i]) {
count=count+1
}
}
winning_rate_Monthly[1,i]=winning_rate_Monthly/(nrow(result-1))
}
for (i in 1:3) {
count=0
for (j in 2:nrow(result)) {
if (result[j,i]>result[j-1,i]) {
count=count+1
}
}
winning_rate_Monthly[1,i]=winning_rate_Monthly/(nrow(result-1))
}
View(winning_rate_Monthly)
View(winning_rate_Monthly)
winning_rate_Monthly[1,i]
winning_rate_Monthly/(nrow(result-1))
for (i in 1:3) {
count=0
for (j in 2:nrow(result)) {
if (result[j,i]>result[j-1,i]) {
count=count+1
}
}
winning_rate_Monthly[1,i]=count/(nrow(result-1))
}
View(winning_rate_Monthly)
table.AnnualizedReturns(tsdata[,1])
table.AnnualizedReturns(tsdata[,1])[1]
table.AnnualizedReturns(tsdata[,1])[2]
table.AnnualizedReturns(tsdata[,1])[1]
table.AnnualizedReturns(tsdata[,1])[1,1]
typeof(table.AnnualizedReturns(tsdata[,1])[1,1])
table.AnnualizedReturns(tsdata[,1])[1,1][1]
typeof(table.AnnualizedReturns(tsdata[,1])[1,1][1])
temp=table.AnnualizedReturns(tsdata[,1])[1,1][1]
View(temp)
variable_summary=data.frame(matrix(nrow = 3,ncol = 6))
rownames(variable_summary)=c("Risk Parity Portfolio",
"Minimum Variance Portfolio",
"Black-Litterman Model")
View(variable_summary)
colnames(variable_summary)=c("年化收益","波动率","夏普比率","最大回撤","VaR","每月胜率")
View(variable_summary)
head(variable_summary)
kable(variable_summary)
table.AnnualizedReturns(tsdata[,1])
table.AnnualizedReturns(tsdata[,1])[1,1][1]
temp=table.AnnualizedReturns(tsdata[,1])[1,1][1]
View(temp)
table.AnnualizedReturns(tsdata[,1])[1,1][1][1,1]
as.numeric(table.AnnualizedReturns(tsdata[,1])[1,1][1])
as.numeric(table.AnnualizedReturns(tsdata[,2])[1,1][1])
table.AnnualizedReturns(tsdata[,1])
variable_summary[1,1]=as.numeri(table.AnnualizedReturns(tsdata[,1])[1,1][1])
variable_summary[1,1]=as.numeric(table.AnnualizedReturns(tsdata[,1])[1,1][1])
View(variable_summary)
variable_summary[2,1]=as.numeric(table.AnnualizedReturns(tsdata[,2])[1,1][1])
variable_summary[3,1]=as.numeric(table.AnnualizedReturns(tsdata[,3])[1,1][1])
View(variable_summary)
table.AnnualizedReturns(tsdata[,1])
print(ArchTest(tsdata[,1]))
table.AnnualizedReturns(tsdata[,1])[1,1][1]
table.AnnualizedReturns(tsdata[,1])[1,1][1]
table.AnnualizedReturns(tsdata[,1])[2,1][1]
variable_summary[1,2]=as.numeric(table.AnnualizedReturns(tsdata[,1])[2,1][1])
variable_summary[2,2]=as.numeric(table.AnnualizedReturns(tsdata[,2])[2,1][1])
variable_summary[3,2]=as.numeric(table.AnnualizedReturns(tsdata[,3])[2,1][1])
View(variable_summary)
variable_summary[1,3]=as.numeric(table.AnnualizedReturns(tsdata[,1])[3,1][1])
variable_summary[2,3]=as.numeric(table.AnnualizedReturns(tsdata[,2])[3,1][1])
variable_summary[3,3]=as.numeric(table.AnnualizedReturns(tsdata[,3])[3,1][1])
View(variable_summary)
maxdrawdown(tsdata[,1])
maxdrawdown(tsdata[,2])
maxdrawdown(tsdata[,3])
maxdrawdown(tsdata[,1])
maxdrawdown(tsdata[,1])[1]
as.numeric(maxdrawdown(tsdata[,1]))
as.numeric(maxdrawdown(tsdata[,1][1]))
as.numeric(maxdrawdown(tsdata[,1])[1])
variable_summary[1,3]=as.numeric(maxdrawdown(tsdata[,1])[1])
variable_summary[2,3]=as.numeric(maxdrawdown(tsdata[,2])[1])
variable_summary[3,3]=as.numeric(maxdrawdown(tsdata[,3])[1])
View(variable_summary)
View(variable_summary)
variable_summary[1,3]=as.numeric(table.AnnualizedReturns(tsdata[,1])[3,1][1])
variable_summary[2,3]=as.numeric(table.AnnualizedReturns(tsdata[,2])[3,1][1])
variable_summary[3,3]=as.numeric(table.AnnualizedReturns(tsdata[,3])[3,1][1])
variable_summary[1,4]=as.numeric(maxdrawdown(tsdata[,1])[1])
variable_summary[2,4]=as.numeric(maxdrawdown(tsdata[,2])[1])
variable_summary[3,4]=as.numeric(maxdrawdown(tsdata[,3])[1])
View(variable_summary)
# VaR
method=1
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,1]
VaR1=VaR1
# VaR
method=1
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,1]
VaR1=quantile(-return,0.95,lw=T)
'VaR1:';VaR1
VaR1=as.numeric(quantile(-return,0.95,lw=T))
'VaR1:';VaR1
# VaR
method=1
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,1]
VaR1=as.numeric(quantile(-return,0.95,lw=T))
method=2
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,method]
VaR2=as.numeric(quantile(-return,0.95,lw=T))
method=3
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,method]
VaR3=as.numeric(quantile(-return,0.95,lw=T))
variable_summary[1,5]=VaR1
variable_summary[2,5]=VaR2
variable_summary[3,5]=VaR3
View(winning_rate_Monthly)
variable_summary[1,6]=winning_rate_Monthly[1,1]
variable_summary[2,6]=winning_rate_Monthly[1,2]
variable_summary[3,6]=winning_rate_Monthly[1,3]
View(winning_rate_Monthly)
View(variable_summary)
head(variable_summary)
View(winning_rate_Monthly)
rm(list = ls())
library(quadprog)
library(quantmod)
library(quadprog)
library(quantmod)
library(quadprog)
library(quantmod)
library(quadprog)
library(quantmod)
library(tseries)
library(tseries)
library(PerformanceAnalytics)
library(PerformanceAnalytics)
library(quadprog)
library(quantmod)
library(quadprog)
library(quantmod)
library(quadprog)
library(quantmod)
library(tseries)
library(tseries)
library(PerformanceAnalytics)
library(PerformanceAnalytics)
getwd()
data=read.csv("data.csv")
data$日期=as.Date(data$日期)
data_no_date=data[,2:7]
library(quadprog)
library(quantmod)
# rm(list = ls())
# 风险平价模型（Risk Parity Portfolio）
earning_rate=data
for (i in 2:7) {
for (j in nrow(data):2) {
earning_rate[j,i]=(data[j,i]-data[j-1,i])/data[j-1,i]
}
}
earning_rate=earning_rate[,2:7]
earning_rate=earning_rate[-1,]
# summary(earning_rate)
RiskParity = function(Sub) #Sub是N行M列的数据，N个日期，M个资产的收益
{
m = ncol(Sub)
Cov = matrix(cov(Sub, use = "na.or.complete"), m, m)
TotalTRC = function(x)
{
x = matrix(c(x, 1-sum(x)))
TRC = as.vector((Cov %*% x) * x)
return(sum(outer(TRC, TRC, "-")^2))
}
sol = optim(par = rep(1/m,m-1), TotalTRC)
w = c(sol$par, 1-sum(sol$par))
return(w)
}
RiskParity(earning_rate)
Configuration_method1=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Configuration_method1[1,]=1/6
for (i in 1:(as.integer(nrow(data)/30)-1)) {
temp=RiskParity(earning_rate[((i-1)*30+1):((i-1)*30+30),])
Configuration_method1[i+1,1]=sum(Configuration_method1[i,])*temp[1]
Configuration_method1[i+1,2]=sum(Configuration_method1[i,])*temp[2]
Configuration_method1[i+1,3]=sum(Configuration_method1[i,])*temp[3]
Configuration_method1[i+1,4]=sum(Configuration_method1[i,])*temp[4]
Configuration_method1[i+1,5]=sum(Configuration_method1[i,])*temp[5]
Configuration_method1[i+1,6]=sum(Configuration_method1[i,])*temp[6]
}
# 去除负值
for (j in 1:6) {
for (i in 1:nrow(Configuration_method1)) {
Configuration_method1[i,j]=Configuration_method1[i,j]-(min(Configuration_method1[i,]))+1e-6
}
}
# 回测
result1=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
result1[1,]=1/6
for (i in 2:nrow(result1)) {
property_sum=sum(result1[i-1,])
rate_sum=sum(Configuration_method1[i,])
for (j in 1:6) {
result1[i,j]=property_sum*
(Configuration_method1[i,j]/rate_sum)*
(data_no_date[(i-1)*30+30,j]/data_no_date[(i-1)*30+1,j])
}
}
for (i in 1:nrow(result1)) {
result1[i,1]=sum(result1[i,])
}
for (i in 2:nrow(result1)) {
result1[i,1]=result1[i-1,1]*result1[i,1]
}
result1=data.frame(result1[,1])
# 最小方差模型（Minimum Variance Portfolio）
earning_rate=data
for (i in 2:7) {
for (j in nrow(data):2) {
earning_rate[j,i]=(data[j,i]-data[j-1,i])/data[j-1,i]
}
}
earning_rate=earning_rate[,2:7]
earning_rate=earning_rate[-1,]
data_no_date=data[,2:7]
Configuration_method2=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
# 先使用Configuration_method2暂存方差列表，并进行标准化
for (j in 1:6) {
for (i in 1:nrow(Configuration_method2)) {
Configuration_method2[i,j]=sd(earning_rate[((i-1)*30+1):((i-1)*30+30),j])
# Configuration_method2[i,j]=Configuration_method2[i,j]*Configuration_method2[i,j]
}
Configuration_method2[,j]=scale(Configuration_method2[,j])
}
# 计算协方差，存储在6个dataframe中
Variance_list1=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Variance_list2=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Variance_list3=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Variance_list4=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Variance_list5=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
Variance_list6=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
for (j in 1:6) {
for (i in 1:nrow(Configuration_method2)) {
Variance_list1[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
earning_rate[((i-1)*30+1):((i-1)*30+30),1],)
}
Variance_list1[,j]=scale(Variance_list1[,j])
}
for (j in 1:6) {
for (i in 1:nrow(Configuration_method2)) {
Variance_list2[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
earning_rate[((i-1)*30+1):((i-1)*30+30),2],)
}
Variance_list2[,j]=scale(Variance_list2[,j])
}
for (j in 1:6) {
for (i in 1:nrow(Configuration_method2)) {
Variance_list3[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
earning_rate[((i-1)*30+1):((i-1)*30+30),3],)
}
Variance_list3[,j]=scale(Variance_list3[,j])
}
for (j in 1:6) {
for (i in 1:nrow(Configuration_method2)) {
Variance_list4[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
earning_rate[((i-1)*30+1):((i-1)*30+30),4],)
}
Variance_list4[,j]=scale(Variance_list4[,j])
}
for (j in 1:6) {
for (i in 1:nrow(Configuration_method2)) {
Variance_list5[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
earning_rate[((i-1)*30+1):((i-1)*30+30),5],)
}
Variance_list5[,j]=scale(Variance_list5[,j])
}
for (j in 1:6) {
for (i in 1:nrow(Configuration_method2)) {
Variance_list6[i,j]=var(earning_rate[((i-1)*30+1):((i-1)*30+30),j],
earning_rate[((i-1)*30+1):((i-1)*30+30),6],)
}
Variance_list6[,j]=scale(Variance_list6[,j])
}
# 协方差的作用是作为方差的约束条件，即满足最小方差规则,此处做该判断
for (i in 1:6) {
for (j in 1:6) {
for (k in 1:nrow(Configuration_method2)) {
# Configuration_method2[i,j]
# get(paste("Variance_list",i,sep = ""))[1,2]
if (Configuration_method2[i,j]<get(paste("Variance_list",i,sep = ""))[k,j]) {
Configuration_method2[i,j]=get(paste("Variance_list",i,sep = ""))[k,j]
}
}
}
}
# 规范化资产配置比例，去除负值（因为要转化为资产配置比例）
for (j in 1:6) {
for (i in 1:nrow(Configuration_method2)) {
Configuration_method2[i,j]=Configuration_method2[i,j]-(min(Configuration_method2[i,]))+1e-6
}
}
# 回测
# 该过程中，将Configuration_method2理解为下一个投资周期全部资产分配的比例
# result存储每次投资后的结果
result2=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
result2[1,]=1/6
for (i in 2:nrow(result2)) {
property_sum=sum(result2[i-1,])
rate_sum=sum(Configuration_method2[i,])
for (j in 1:6) {
result2[i,j]=property_sum*
(Configuration_method2[i,j]/rate_sum)*
(data_no_date[(i-1)*30+30,j]/data_no_date[(i-1)*30+1,j])
}
}
for (i in 1:nrow(result2)) {
result2[i,1]=sum(result2[i,])
}
result2=data.frame(result2[,1])
# Black-Litterman Model
# 计算风险指数，这里理解为每个投资周期亏空日期占比
risk=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
for (i in 1:nrow(risk)) {
for (j in 1:6) {
count=0
for (k in 2:30) {
if (data_no_date[(i-1)*30+k,j]>data_no_date[(i-1)*30+k-1,j]) {
count=count+1
}
}
risk[i,j]=count/30
}
}
# 确定风险水平与主观预期影响下收益最大化的配置策略
# 主观预期是该模型的重点，这里认为是上期投资的收益率在影响
# 在实际模型中可能是新闻资讯，关联市场状况等的影响,但此处无法获得这些信息
Configuration_method3=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
for (i in 1:nrow(Configuration_method3)) {
for (j in 1:6) {
Configuration_method3[i,j]=(data_no_date[(i-1)*30+30,j]-data_no_date[(i-1)*30+1,j])/data_no_date[(i-1)*30+1,j]*risk[i,j]
}
}
for (j in 1:6) {
for (i in 1:nrow(Configuration_method3)) {
Configuration_method3[i,j]=Configuration_method3[i,j]-(min(Configuration_method3[i,])+1e-6)
}
}
# 回测
result3=data.frame(matrix(ncol = 6,nrow = as.integer(nrow(data)/30)))
result3[1,]=1/6
# 同上，将Configuration_method3理解为下一个投资周期全部资产分配的比例
# result3存储每次投资后的结果
for (i in 2:nrow(result3)) {
property_sum=sum(result3[i-1,])
rate_sum=sum(Configuration_method3[i,])
for (j in 1:6) {
result3[i,j]=property_sum*
(Configuration_method3[i,j]/rate_sum)*
(data_no_date[(i-1)*30+30,j]/data_no_date[(i-1)*30+1,j])
}
}
for (i in 1:nrow(result3)) {
result3[i,1]=sum(result3[i,])
}
result3=data.frame(result3[,1])
# 指标分析与模型选择
result=data.frame(result1,result2,result3)
result[1,]=1
result=result[1:85,]
colnames(result)=c("M1","M2","M3")
# 年化收益、波动率和夏普比率
library(PerformanceAnalytics)
tsdata=ts(result)
table.AnnualizedReturns(tsdata[,1])
table.AnnualizedReturns(tsdata[,2])
table.AnnualizedReturns(tsdata[,3])
# 最大回撤
library(tseries)
maxdrawdown(tsdata[,1])[1]
maxdrawdown(tsdata[,2])[1]
maxdrawdown(tsdata[,3])[1]
# VaR
method=1
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,1]
VaR1=as.numeric(quantile(-return,0.95,lw=T))
"VaR1:";VaR1
method=2
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,method]
VaR2=as.numeric(quantile(-return,0.95,lw=T))
"VaR2:";VaR2
method=3
return=data.frame(matrix(ncol = 3,nrow = as.integer(nrow(data)/30)))
for(i in 2:(nrow(result)-1)){
return[i,method]=diff(result[,method])[i-1]/result[i-1,method]
}
return=return[2:84,method]
VaR3=as.numeric(quantile(-return,0.95,lw=T))
"VaR3:";VaR3
# 每月胜率
winning_rate_Monthly=data.frame(matrix(nrow = 1,ncol = 3))
colnames(winning_rate_Monthly)=c("Risk Parity Portfolio",
"Minimum Variance Portfolio",
"Black-Litterman Model")
for (i in 1:3) {
count=0
for (j in 2:nrow(result)) {
if (result[j,i]>result[j-1,i]) {
count=count+1
}
}
winning_rate_Monthly[1,i]=count/(nrow(result-1))
}
# 变量汇总
variable_summary=data.frame(matrix(nrow = 3,ncol = 6))
colnames(variable_summary)=c("年化收益","波动率","夏普比率","最大回撤","VaR","每月胜率")
rownames(variable_summary)=c("Risk Parity Portfolio",
"Minimum Variance Portfolio",
"Black-Litterman Model")
variable_summary[1,1]=as.numeric(table.AnnualizedReturns(tsdata[,1])[1,1][1])
variable_summary[2,1]=as.numeric(table.AnnualizedReturns(tsdata[,2])[1,1][1])
variable_summary[3,1]=as.numeric(table.AnnualizedReturns(tsdata[,3])[1,1][1])
variable_summary[1,2]=as.numeric(table.AnnualizedReturns(tsdata[,1])[2,1][1])
variable_summary[2,2]=as.numeric(table.AnnualizedReturns(tsdata[,2])[2,1][1])
variable_summary[3,2]=as.numeric(table.AnnualizedReturns(tsdata[,3])[2,1][1])
variable_summary[1,3]=as.numeric(table.AnnualizedReturns(tsdata[,1])[3,1][1])
variable_summary[2,3]=as.numeric(table.AnnualizedReturns(tsdata[,2])[3,1][1])
variable_summary[3,3]=as.numeric(table.AnnualizedReturns(tsdata[,3])[3,1][1])
variable_summary[1,4]=as.numeric(maxdrawdown(tsdata[,1])[1])
variable_summary[2,4]=as.numeric(maxdrawdown(tsdata[,2])[1])
variable_summary[3,4]=as.numeric(maxdrawdown(tsdata[,3])[1])
variable_summary[1,5]=VaR1
variable_summary[2,5]=VaR2
variable_summary[3,5]=VaR3
variable_summary[1,6]=winning_rate_Monthly[1,1]
variable_summary[2,6]=winning_rate_Monthly[1,2]
variable_summary[3,6]=winning_rate_Monthly[1,3]
head(variable_summary)
rm(list = ls())
